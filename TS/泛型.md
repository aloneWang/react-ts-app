## 释义
支持多种类型的数据， 解决 创建可重用的 组件
例子
`泛型函数`
```
function identity<T>(arg:T): T { 
  return arg
}
```
#### 注意
在函数主体中 ，你是无法知道这个类型时什么类型， 除非，你在参数中定义了
```
function fn<T>(arg:T):T {
  return arg.length // error
}
```
在没有明确指定T的arg的类型的时候， 访问属性是报错的，编译之前会检测的

```
function fn<T>(arg: T[]): T[] {
  return arg
}
```
## 泛型类型
```
function identity<T>(arg:T): T {
  return arg
}
let fn: <T>(arg:T) => T = identity
```
也可以是使用 泛型 接口 定义泛型函数
```
interface IdentityFn {
  <T>(arg:T): T
}
let fn: IdentityFn = identity
```
也可以使用 带有签名的对象字面量定义函数泛型函数
```
let fn: { <T>(arg:T): T } = identity
```
## 泛型接口
锁定泛型接口的类型， 成员可以使用该类型
```
interface IdentityFn<T> {
  (arg:T): T
}
let fn: IdentityFn<number> = identity
```
## 泛型类
和 泛型接口差不多
```
class identityClass<T> {
  value: T;
  add: (x: T, y: T) => T
}
```
` 注意` 类的静态属性不能使用 泛型
## 泛型约束
```
interface Lengthwise {
  length: number
}
class LoggingIdentity<T exdents Lengthwize>(arg: T):T {
  return arg.length
}
```
这个函数被定义了约束，必须包含 length属性
// 可以不用这样写 LoggingIdentity<number>(3), 类型推断了
LoggingIdentity(3) // error

## 在泛型里使用 类类型
类类型 也可作 接口
```
class Beekeeper {
  hasMask: Boolean
}
class ZooKeeper {
  nametag: string;
}

class Animal {
  numLegs: number;
}
class Bee extends Animal {
  keeper: Beekeeper
}
class Lion extends Animal {
  keeper: ZooKeeper
}
function createInstance<A extends Animal>(c: new () => A):A {
  return new c()
}
createInstance(Lion).keeper.nametag
createInstance(Bee).keeper.hasMask
```


