## 释义
用来约束你所声明的对象，类，函数， 对值所具有的结构的进行类型检查

`example`:
```
interface LabelledValue {
  label: string
}
function printLabel(labelledobj: LabelledValue): void {
  // do sth
}

let myobj = let myObj = {size: 10 }
printLabel(myobj)
```
## 可选属性
接口定义的属性不完全是必须的，在冒号的前面使用问号 ` ? ` 表示 这是个非必须的属性

```
interface SquareConfig {
  color?: string;
  width?: number;
}
```
## 只读属性
只在创建的时候能修改其值， 使用 ` readonly ` 来指定 只读属性

```
interface Point {
  readonly x: number;
  readonly y: string;
}
let p:Point = {x: 1, y: '12'}
p.x = 3 // 无法分配到 "x" ，因为它是只读属性。ts(2540)
```
ts 具有 ` ReadonlyArray<T>`, 他与 `Array<t>` 相似，只是把所有可变的方法去掉了，确保数组创建后再也不能被修改
```
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

## 索引签名
这里的索引签名有两种， 字符串 和 数字

`注意`： 数字索引的返回值必须是字符串 索引返回值类型的子类型 

这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致。

```
interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
  [index: string]: any
}
```

## 函数类型
描述函数类型
```
interface SearchFunc {
  (source: string, sunstring: string)： boolean;
}
let mySearch: SearchFunc;
// 这边直接使用了类型断言
mySearch = function (surce, sub) {
  return true
}
```

## 类类型
约束类，实现的类类型
```
interface ClockInterface {
  currentTime: Date;
  setTime(d:Date);
}
// 实现类类型
class Clock implements ClockInterface {
  currentTime: Date;
  setTime(d: Date) {
    // do sth
  }
  constructor(h: number, m: number) {}
}
```
`注意`： 接口描述类的公共部分，而不是公共和私有部分。他不会帮你检查私有成员
当一个类实现一个接口时，只对其实例部分检查， 不会对静态部分检查， constructor 属于静态部分，不属于检查范围内

```
interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
// 类“Clock”错误实现接口“ClockConstructor”。
//  类型“Clock”提供的内容与签名“new (hour: number, minute: number): any”不匹配
```

## 继承接口
和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。

```
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
```
## 混合类型
一个类型可以拥有多种类型，可以有函数类，对象类
```
interface Counter {
 (start: number): string; // 函数
 interval: number; // 普通属性
 reset():void // 类方法
}

function getCounter(): Counter {
  let counter = <Counter>function(star: number) {};
  counter.interval = 1212;
  counter.reset = function() {}
  return counter
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

## 接口继承类
接口继承类的所有成员，包括私有成员，但不包括实现

当你继承了一个拥有私有或受保护成员的类时， 这个接口只能被这个类或其子类实现

```
class Control {
  private state: any
}
interface SelectableControl extends Control {
  select():void
}
class Button extends Control implements SelectableControl {
  select() {

  }
}
class Image implements SelectableControl {
  select() {} // error
}
```