## private 
私有属性
当一个成员被标记 `private` 时候，是不能在 这个类外访问的
```
class Animal {
  private name: string
  constructor(name: string) {
    this.name = name
  }
}
new Animal('dog').name // error name 是私有的
```

## 理解 protected
受保护的属性
`protected` 和 `private` 修饰符的属性相似， 但是 `protected` 成员 可以在 派生类 中 访问
## 类型比较
比较两个类型时候，如果所有的成员的类型都是兼容的，类型也就是兼容的， `private` 和 `protected` 有个前提规则， 他们必须来自同一处声明

```
class Animal {
  private name: string;
  constructor(theName: string) {
    this.name = theName
  }
}

class Rhino extends Animal {
  constructor(name) {
    super(name)
  }
}

class Employee {
  private name: string;
  constructor(theName) {
    this.name = theName
  }
}
let animal = new Anima('dog')
let rhino = new Rhino('gg')
let employee = new Employee('Bob')
animal = rhino
animal = employee  // Animal 与 Employee 不兼容
```
## readonly 只读属性修饰符

## 抽象类
作为派生类的基类使用，一般不会被实例化， `abstract` 关键字用于定义抽象类的 和 抽象类内部定义抽象方法
```
abstract class Animal {
  abstract makeSound():void
}
```
抽象方法和接口的方法类似，都是定义签名 不包含方法体， `makeSound ` 必须在派生类中实现
```
class AccountingDepartment extends Animal {
  makeSound():viod {
    // do sth
  }
}
animal = new Anima() // error 不能创建一个抽象类的实例
```
